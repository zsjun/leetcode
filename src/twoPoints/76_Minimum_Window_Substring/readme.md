## 76. 最小覆盖子串

### 题目描述

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
<br/>

说明:<br/>

1 如果 s 中存在这样的子串，我们保证它是唯一的答案。<br/>

进阶：<br/>
你能设计一个在 o(n) 时间内解决此问题的算法吗？<br/>

例子1<br/>

输入：s = "ADOBECODEBANC", t = "ABC"
<br/>
输出："BANC"<br/>

例子2<br/>

输入：s = "a", t = "a"
<br/>
输出："a"<br/>



提示：<br/>

1 1 <= s.length, t.length <= 10^5<br/>
2 s 和 t 由英文字母组成<br/>



### 思考 1


1 这里首先想到的肯定是双指针，因为这个专题就是双指针， 所以首先想到的肯定是设置两个指针，一个slow，一个fast，
slow的位置肯定是小于或者等于fast指针的位置。<br/>
然后遍历字符串，找到包含所有t的子串，然后再不断更新slow指针，那么下一个问题就变成了按照什么规则更新slow指针？<br/>
然后很自然就会想到因为我们是找的最短的字符串，所以如果slow指针不断前进的时候，如果发现slow现在所指的字符不在t中，当然可以继续前进，因为slow在这种情况下前进，肯定不会影响最短字符串的是否包含t中的所有字符的。<br/>
当发现slow指针指的字符在t中的时候，这个时候因为字符串还没有遍历完，所以我们还是需要继续遍历下去的，否则不能肯定现在找到的是最短的字符串是s中能找到的包含t的最短字符串，这个时候就要更新slow指针，也就是让从我们找到的最短字符串中删除一个在t中的字符且在我们的找到的最短字符串中重复的次数不大于在t中出现的次数的字符。<br/>
<br/>

这个题目有些不是很好理解的地方，可能就是在理解slow指针应该怎么前进？<br/>

比如 s="ADOBECODEBANC"，t="ABC"的时候，<br/>

我们可以很容易的发现slow = 0，fast = 5的时候，也就是"ADOBEC"的时候是包含所有t的字符的，这时候最短字符串就是"ADOBEC"<br/>

然后想办法从"ADOBEC" 删除掉一个在t中且在我们找到的最短字符串"ADOBEC"重复次数小于在t中重复的次数，当然这个例子中，t 不包含重复的字符，<br/>
可以发现A在t中，所以slow一直前进到1，然后fast前进到10，此时又发现新的包含t的字符串“DOBECODEBA”<br/>
因为D和O不在t中，所以slow可以一直前进到4，也就是变成slow=4,fast=10<br/>
这个时候重点就来了，slow下一步如何前进，如果此时slow前进到4，可以发现“B”在t中，那么是不是就删除"B",让slow=5，让fast继续寻找“B”呢？很明显不行，因为“ECODEBA”里边有"B",没有必要去寻找"B"<br/>
所以slow还得继续前进，一直前进到slow=7，也就是删除“C”,这个时候待查找字符串就变成了“ODEBA”,这样就可以让fast去寻找 “C”了。

如果还是不懂，可以看一下代码，主要看下是如何不断的更新slow的,<br/>
关键的一点是记住更新slow的目的是为了在已经查找的最短字符串中删除一个字符，然后让fast再去寻找到一个，形成新的最短字符串<br/>

通过这个题可以学习一下如何维持一个滑动窗口的状态，不断的从窗口中删除和不断的添加到滑动窗口<br/>



这里的时间复杂度可以很容易的看出是O（s.length），空间复杂度O(t.length)








