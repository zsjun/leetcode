## 76. 最小覆盖子串

### 题目描述

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
<br/>

说明:<br/>

1 如果 s 中存在这样的子串，我们保证它是唯一的答案。<br/>

进阶：<br/>
你能设计一个在 o(n) 时间内解决此问题的算法吗？<br/>

例子1<br/>

输入：s = "ADOBECODEBANC", t = "ABC"
<br/>
输出："BANC"<br/>

例子2<br/>

输入：s = "a", t = "a"
<br/>
输出："a"<br/>



提示：<br/>

1 1 <= s.length, t.length <= 10^5<br/>
2 s 和 t 由英文字母组成<br/>



### 思考 1


1 这里首先想到的肯定是双指针，因为这个专题就是双指针， 这里可以设置两个指针，一个low，一个fast，low的位置肯定是小于或者等于fast指针的位置。首先遍历字符串，找到包含所有t的子串，然后再不断更新low指针，那按照什么规则更新low指针呢？<br/>
很容易就想到因为我们是找的最短的字符串，所以如果low指针不断前进的时候，如果发现low现在所指的字符不在t中，当然可以继续前进，因为low在这种情况下前进，肯定不会影响结果的<br/>
当发现low指针指的字符在t中的时候，这个时候因为字符串还没有遍历完，所以我们还是需要继续遍历下去的，否则不能肯定现在找到的是最短的字符串，那怎么更新呢？<br/>
肯定是low前进一步，然后继续前进fast指针，不断的前进，直到fast指针找到刚才low所指的字符，再继续重复上面的步骤就可以了。



