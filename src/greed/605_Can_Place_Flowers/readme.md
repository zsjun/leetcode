## 605. 种花问题

### 题目描述

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。


例子

输入是一个数组，数组由多个长度固定为 2 的数组组成，表示区间的开始和结尾。输出一个 整数，表示需要移除的区间数量。

输入: flowerbed = [1,0,0,0,1], n = 1
输出: True

在这个样例中，可以把花种在2的位置上

输入: flowerbed = [1,0,0,0,1], n = 2
输出: False

因为这里有两颗花，不论第一棵花种在哪里，都会有相连的，从而导致有连在一起的两颗花

注意:

1 数组内已种好的花不会违反种植规则。
2 输入的数组长度范围为 [1, 20000]。
3 n 是非负整数，且不会超过输入数组的大小。


### 思考 1

贪心算法首先最重要的就是要寻找到最优解？
那这里的最优解是什么呢？或者换句话说我们怎么做才是最贪心的呢？

当 [1,0,0,0,1], n = 1的时候，最贪心的肯定是从第一个可以种的位置种植<br/>

当 [1,0,0,0,1], n = 2的时候，最贪心的肯定是从第一个可以种的位置种植,如果发现第二个没有位置可以种植，则返回false


### 实现1

```
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
// [1, 0, 0, 0, 1]
// [1,0,0,0,1,0,0]
export default (flowerbed, n) => {
  for (let i = 0; i < flowerbed.length; ) {
    if (i === 0 && flowerbed[i] === 0 && flowerbed[i + 1] !== 1) {
      flowerbed[i] === 1;
      n--;
      i += 2;
    } else if (i === flowerbed.length - 1 && flowerbed[i] === 0 && flowerbed[i - 1] !== 1) {
      n--;
      i++;
    } else if (flowerbed[i] === 0 && flowerbed[i - 1] !== 1 && flowerbed[i + 1] !== 1) {
      flowerbed[i] = 1;
      n--;
      i += 2;
    } else {
      i++;
    }
  }
  return n <= 0;
};


```
时间复杂度O（n）空间复杂度O（1）

